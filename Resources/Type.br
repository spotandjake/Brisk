// type Test = String[4];
// type Test1 = String | String[4];
// type Test2 = (String | String[4]);
// const array: i32[] = [
//   1n,
//   2n,
//   3n,
//   4n
// ];
// TODO: ensure you put in the Array Length when it cant be inferred
// const test: Test = 1n;
// type Test = string | Test[];
// type Te = string | Te;
// type T = T;
// interface TestInterface2 {
//   test: string;
// }
// interface TestInterface {
//   test?: TestInterface;
// }
// interface TestInterface3 {
//   test: TestInterface3;
// }
// if (<Boolean>1) {
//   const test: i32 = 1n;
// };
// let test: i64 = <i64>1n;
// test = 2N;
// const arrayTest: (i32 | i64)[] = [
//   1n,
//   2n,
//   3n,
//   1N
// ];
// Ensure This Works ^
// const testFunc: Function = (t: i32): Void => {

// };
// testFunc(1n);
const t: i32 = @wasm.i32.add(1n, 1n);
// type T = <GenericTest>(GenericTest) => GenericTest;
// const testFunction: Function = <Generic>(t: Generic, test?: Generic): Generic => {
    
// };
// const test: i32 = testFunction(1n, 1n);
// const test1: i32 = testFunction(1n, 1N);
// const test1: i32 = 1n;
// test.test = 1n;
// type T = (i32 | i64);
// type FunctionTypeTest = (i32, i64) => i32;
// interface TestLiteral {
//   let test: i32[];
// }
// const testObject: { test1: i32; } = {
//   test1: 2n
// };
// const testLiteral: TestLiteral = {
//   ...testObject,
//   test: 1n
// };
// testLiteral.test = 2n;
// type TypeTest<GenericTest, GenericTest1> = String;
// interface TestInterface<GenericTest> {
//   test: GenericTest;
// }
// enum EnumTest<GenericTest> {
//   Test(GenericTest)
// }
// const nonGenericFunction: Function = (): Void => {
//   return();
// };
// const genericFunction: Function = <T>(arg: T): T => {
//   return(arg);
// };
const retTest: Function = (t: i32): i32 => {
  if (true) {
    return(1n);
  } else {
    return(1n);
  };
};

// let comparisonCheckPass: Boolean = 1 < 1;
// let arithmeticCheckPass: Number = 1 + 1;