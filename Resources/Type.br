// type Test = String[4];
// type Test1 = String | String[4];
// type Test2 = (String | String[4]);
// const array: i32[] = [
//   1n,
//   2n,
//   3n,
//   4n
// ];
// TODO: ensure you put in the Array Length when it cant be inffered
// const test: Test = 1n;
// type Test = string | Test[];
// type Te = string | Te;
// type T = T;
// interface TestInterface2 {
//   test: string;
// }
// interface TestInterface {
//   test?: TestInterface;
// }
// interface TestInterface3 {
//   test: TestInterface3;
// }
// if (<Boolean>1) {
//   const test: i32 = 1n;
// };
// let test: i64 = <i64>1n;
// test = 2N;
// const arrayTest: (i32 | i64)[] = [
//   1n,
//   2n,
//   3n,
//   1N
// ];
type T = <GenericTest>(GenericTest) => GenericTest;
const testFunction: T = <Generic>(t: Generic): Generic => {

};
const test: i32 = testFunction();
// test.test = 1n;
// type T = (i32 | i64);
// type FunctionTypeTest = (i32, i64) => i32;
// interface TestLiteral {
//   let test: i32[];
// }
// const testObject: { test1: i32; } = {
//   test1: 2n
// };
// const testLiteral: TestLiteral = {
//   ...testObject,
//   test: 1n
// };
// testLiteral.test = 2n;
// type TypeTest<GenericTest, GenericTest1> = String;
// interface TestInterface<GenericTest> {
//   test: GenericTest;
// }
// enum EnumTest<GenericTest> {
//   Test(GenericTest)
// }
// const nonGenericFunction: Function = (): Void => {
//   return();
// };
// const genericFunction: Function = <T>(arg: T): T => {
//   return(arg);
// };